name "agrobv16_stage"

# simulation timestep in milliseconds
interval_sim 100

# stop the simulation after this many simulated seconds have elapsed
quit_time 0

# set the resolution of the underlying raytrace model in meters
resolution 0.01

#if non-zero, print the simulation time on stdout every $show_clock_interval updates
#show_clock 0

#sets the number of updates between printing the time on stdoutm, if $show_clock is enabled
show_clock_interval 125

#the number of worker threads to spawn. Some models can be updated in parallel (e.g. laser, ranger), and running 2 or more threads here may make the simulation run faster
threads 2

#visualization definition
window(
  #size of the window in pixels
  size [700 600]
  #camera options
  #location of the center of the window in world coordinates (meters)
  center [0 0]
  #angle relative to straight up, angle of rotation (degrees), rotate [ <pitch:float> <yaw:float> ]
  rotate [0 0]
  #ratio of world to pixel coordinates (window zoom)
  scale 10.0
  # perspective camera options
  #location of the perspective camera (meters), pcam_loc [ <x:int> <y:int> <z:int> ]
  pcam_loc [ 0 -2 2 ]
  #verticle and horizontal angle of the perspective camera, pcam_angle [ <pitch:float> <yaw:float> ]
  pcam_angle [ 60 0 ]
  #whether to start with the perspective camera enabled (0/1)
  pcam_on 0
  # GUI options
  show_data 1
  show_flags 1
  show_blocks 1
  show_clock 1
  show_footprints 0
  show_grid 1
  show_trailarrows 0
  show_trailrise 0
  show_trailfast 0
  show_occupancy 0
  #show_tree 0 dont work
  pcam_on 0
  screenshots 0
)

#Map definition
model
(
  name "hiper_centro_map"
  #specify the pose of the model in its parent's coordinate system, pose [ x:<float> y:<float> z:<float> heading:<float> ] 
  pose [0.0 0.0 0.0 0.0]
  #specify the size of the model in each dimension, specify the size of the model in each dimension, size [ x:<float> y:<float> z:<float> ]
  size [59.55 73.3 2.5]
  #specify the position of the object's center, relative to its pose, origin [ x:<float> y:<float> z:<float> heading:<float> ]
  origin [ 0.0 0.0 0.0 0.0 ]
  #specify the color of the object using a color name from the X11 database (rgb.txt)
  color "gray30"
  #Iff true, 4 thin blocks are automatically added to the model, forming a solid boundary around the bounding box of the model
  boundary 0
  #Draw the model by interpreting the lines in a bitmap (bmp, jpeg, gif, png supported). The file is opened and parsed into a set of lines.
  #The lines are scaled to fit inside the rectangle defined by the model's current size
  bitmap "map_hiper_centro_all_1.pgm"
	
  # GUI properties
  #if 1, draw a bounding box around the model, indicating its size
  gui_outline 1
  #if 1, the model can be moved by the mouse in the GUI window
  gui_move 0

  # determine how the model appears in various sensors	
  ranger_return 1
)

#obstacle definition
define block model(
  name "block"
  #specify the pose of the model in its parent's coordinate system, pose [ x:<float> y:<float> z:<float> heading:<float> ]
  pose [0 0.5 0 0]
  #specify the size of the model in each dimension, specify the size of the model in each dimension, size [ x:<float> y:<float> z:<float> ]
  size [2.00 2.00 2.50]
  #if 1, draw a nose on the model showing its heading (positive X axis)
  gui_nose 0
  color "red"

  # determine how the model appears in various sensors	
  ranger_return 1	
)

define block_small model(
  name "block"
  #specify the pose of the model in its parent's coordinate system, pose [ x:<float> y:<float> z:<float> heading:<float> ]
  pose [0 0.5 0 0]
  #specify the size of the model in each dimension, specify the size of the model in each dimension, size [ x:<float> y:<float> z:<float> ]
  size [1.00 3.00 2.50]
  #if 1, draw a nose on the model showing its heading (positive X axis)
  gui_nose 0
  color "red"

  # determine how the model appears in various sensors	
  ranger_return 1	
)

define laser_generic ranger
(
  # laser properties
  #the number of laser samples per scan
  #samples 360
  #the maximum range reported by the scanner, in meters.
  #The scanner will not detect objects beyond this range
  #range_max 5.0
  #the angular field of view of the scanner, in degrees
  #fov 360
  #Only calculate the true range of every nth laser sample.
  #The missing samples are filled in with a linear interpolation.
  #Generally it would be better to use fewer samples, but some (poorly implemented!) programs expect a fixed number of samples.
  #Setting this number > 1 allows you to reduce the amount of computation required for your fixed-size laser vector. 
  #resolution 1

  #generates laser noise
  #ctrl "lasernoise"

  sensor(
    range [0 50]
    fov 360
    samples 288
  )
  # generic model properties
  size [0.05 0.05 0.1]
  color "blue"
)

define Jarvis_robot position(
  #specify the size of the model in each dimension, specify the size of the model in each dimension, size [ x:<float> y:<float> z:<float> ]
  size [0.790 0.500 0.23]

  # position properties
  #select differential-steer model(like a Pioneer), omnidirectional mode or carlike (velocity and steering angle), drive "diff", "omni" or "car"
  drive "car"
  #if "gps" the position model reports its position with perfect accuracy.
  #If "odom", a simple odometry model is used and position data drifts from the ground truth over time.
  #The odometry model is parameterized by the odom_error property
  localization "odom"
  #specify the position of the object's center, relative to its pose, origin [ x:<float> y:<float> z:<float> heading:<float> ]
  origin [0.26 0.0 0.0 0.0]

  # odometry error model parameters, 
  # only used if localization is set to "odom"
  #parameters for the odometry error model used when specifying localization "odom".
  #Each value is the maximum proportion of error in intergrating x, y, and theta velocities to compute odometric position estimate.
  #For each axis, if the the value specified here is E, the actual proportion is chosen at startup at random in the range -E/2 to +E/2.
  #Note that due to rounding errors, setting these values to zero does NOT give you perfect localization - for that you need to choose localization "gps". 
  odom_error [0.001 0.0003 00.00 0.2]

  # GUI properties
  #if 1, draw a nose on the model showing its heading (positive X axis)
  gui_nose 1

  laser_generic(pose [0.0 0.0 0.0 0.0])
)


block(pose [10.0 0.0 0.0 0.0])
block(pose [15.0 0.0 0.0 0.0])
block(pose [20.0 0.0 0.0 0.0])
block(pose [25.0 0.0 0.0 0.0])
block(pose [30.0 0.0 0.0 0.0])
block(pose [35.0 0.0 0.0 0.0])

block_small(pose [10.0 3.0 0.0 0.0])
block_small(pose [15.0 3.0 0.0 0.0])
block_small(pose [20.0 3.0 0.0 0.0])
block_small(pose [25.0 3.0 0.0 0.0])
block_small(pose [30.0 3.0 0.0 0.0])
block_small(pose [35.0 3.0 0.0 0.0])
Jarvis_robot(
  pose [ -1.0 -21.0 0.0 90.0 ]
  name "Jarvis"
  color "gray"
)
